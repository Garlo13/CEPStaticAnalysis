/*
 * generated by Xtext 2.13.0
 */
package org.xtext.example.mydsl.generator

import org.eclipse.emf.ecore.resource.Resource
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IFileSystemAccess2
import org.eclipse.xtext.generator.IGeneratorContext
import java.util.HashMap
import java.util.List
import org.xtext.example.mydsl.esper.Insert
import org.xtext.example.mydsl.esper.Domainmodel
import java.util.Stack
import java.util.ArrayList
import org.eclipse.emf.common.util.EList
import org.xtext.example.mydsl.esper.RuleParts
import java.util.Set
import java.util.Map
import org.xtext.example.mydsl.esper.KindOfEvent
import org.xtext.example.mydsl.esper.AbstractFollowBy
import java.util.stream.Collectors
import org.xtext.example.mydsl.esper.FollowBy
import org.xtext.example.mydsl.esper.TerminalExpression
import org.xtext.example.mydsl.esper.Event

/**
 * Generates code from your model files on save.
 * 
 * See https://www.eclipse.org/Xtext/documentation/303_runtime_concepts.html#code-generation
 */
class EsperGenerator extends AbstractGenerator {

	val mapEvents = new HashMap<String, List<String>>()
	val mapUniqueId = new HashMap<String, List<String>>()
	//------------------FOR-PASSING-BETWEEN-REAL-NAME-AND-ID
	val mapRulePartsToString = new HashMap<Insert, String>()
	val mapSimpleEventToString = new HashMap<String, String>()
 	//------------------FOR-PRIORITIES
	var mapGeneratedPriorities = new HashMap<String, Integer>()
	val mapRealPriorities = new HashMap<String, Integer>()

	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		mapEvents.clear
		mapRulePartsToString.clear
		mapSimpleEventToString.clear
		mapUniqueId.clear
		
		mapGeneratedPriorities.clear
		mapRealPriorities.clear
		
		var domainModel = resource.contents.head as Domainmodel
		val simpleEventList = newArrayList
		val complexEventList = domainModel.rules
		domainModel.events.forEach[event | simpleEventList.add(event.name) ]
		
		val orderRuleStack = new Stack<String>()
		makeIntToRuleNameMap(simpleEventList.toList, complexEventList, orderRuleStack)	
		
		makeMap(simpleEventList.toList, complexEventList)
		
		var graphUtils = new GraphUtils(mapUniqueId)
		val stronglyConnected = new StronglyConnectedComponentDiGraph(mapUniqueId)
		val fileName = resource.URI.lastSegment.replace(".esper", "").replace("-", "")
		
		if (stronglyConnected.isThereAnySCC){
			val scc = stronglyConnected.simplifiedSCCDiGraph
			
			generateStronglyConnectedComponent(fsa, fileName, simpleEventList, complexEventList, scc)
		} else{
			//makeRealPrioritiesMap(complexEventList)
			makePriorityMap(graphUtils)
			
			val priorityGenerator = new PriorityGenerator(resource.URI, mapGeneratedPriorities, orderRuleStack)
			generateGraphWithPriorities(fsa, fileName, priorityGenerator)
		}
	}
	
	
	def generateStronglyConnectedComponent(IFileSystemAccess2 fsa,
			String fileName, 
			ArrayList<String> simpleEventList, 
			EList<RuleParts> complexEventList,
			List<Set<String>> scc
	) {
		fsa.generateFile(fileName + '.dot', 
			'''
			digraph «fileName» {
				«FOR entry : mapSimpleEventToString.entrySet»
				«entry.value» [shape="box", label="«entry.key»"];
				«ENDFOR»
				«FOR entry : mapRulePartsToString.entrySet»
				«entry.value» [shape="oval", label="«entry.key.name»"];
				«ENDFOR»
				«FOR entry : mapUniqueId.entrySet»
					«FOR dependencie : entry.value»
					«IF isThereAnySetContainingThisPairOfNodes(entry.key, dependencie, scc)»
						«dependencie» -> «entry.key» [color=firebrick1]
					«ELSE»
						«dependencie» -> «entry.key»
					«ENDIF»
					«ENDFOR»
				«ENDFOR»
			}	
			'''
		) 
		
		generateLogFileWithSCC(fileName, fsa, scc)
	}
	
	def generateLogFileWithSCC(String fileName, IFileSystemAccess2 fsa, List<Set<String>> scc) {
		fsa.generateFile(fileName + "Log.txt",
			'''
			*************************************************************************
						 
			Se han encontrado ciclos en la estructura de las reglas. Por lo tanto, no se ha podido
			generar las prioridades para cada regla.
			
			 
			Se han generado un ficheros:
				- «fileName».dot donde puede encontrar una representación del grafo de dependencias
				
			*************************************************************************
			 
			Se han encontrado las siguientes componentes conexas:
			
				«FOR set : scc»
					- «set.stream.map[uniqueID | getRuleNameFromUniqueID(uniqueID) + " (" + uniqueID + ")"  ].collect(Collectors.joining(",", "[", "]"))»
				«ENDFOR»
			*************************************************************************	
			'''
		)
	}
	
	def getRuleNameFromUniqueID(String id){
		mapRulePartsToString.entrySet.stream
			.filter[ entry | entry.value.equals(id)]
			.map[entry | entry.key.name]
			.collect(Collectors.toList())
			.get(0)
	}
	
	def boolean isThereAnySetContainingThisPairOfNodes(String node1, String node2, List<Set<String>> scc) {
		scc.stream.anyMatch[set | set.containsAll(newHashSet(node1, node2))]
	}
	
	def generateGraphWithPriorities(IFileSystemAccess2 fsa, 
		String fileName,
		PriorityGenerator priorityGenerator
	) {
		val prioritiesFileName = fileName + 'Priorities.esper'
		val logMap = new HashMap<String, String>
		
		fsa.generateFile(fileName + '.dot', 
			'''
			digraph «fileName» {
				«FOR entry : mapSimpleEventToString.entrySet»
					«entry.value» [shape="box", label="«entry.key»"];
				«ENDFOR»
				«FOR entry : mapRulePartsToString.entrySet»
					«IF mapRealPriorities.get(entry.value) != mapGeneratedPriorities.get(entry.value)»
						«addEntryToMap(logMap,entry.key.name, entry.value)»
						«entry.value» [shape="oval", label="«entry.key.name»", color=firebrick1];
					«ELSE»
						«entry.value» [shape="oval", label="«entry.key.name»"];
					«ENDIF»
				«ENDFOR»
				«FOR entry : mapUniqueId.entrySet»
					«FOR dependencie : entry.value»
						«dependencie» -> «entry.key»
					«ENDFOR»
				«ENDFOR»
			}
			'''
		) 
		
		fsa.generateFile(prioritiesFileName, priorityGenerator.makePriorityFile() )
		
		generateLogFilePriorities(fileName, fsa, logMap)
	}
	
	def generateLogFilePriorities(String fileName, IFileSystemAccess2 fsa, Map<String, String> map) {
		fsa.generateFile(fileName + "Log.txt", 
			'''
			*************************************************************************
			 
			No se han encontrado ciclos en la estructura de las reglas.
			 
			Se han generado dos ficheros:
				- «fileName».dot donde puede encontrar una representación del grafo de dependencias
				
				- «fileName»Priorities.esper donde puede encontrar las reglas introducidadas pero  
				con las prioridades generadas (según orden topológico).
				
			*************************************************************************
			«IF map.empty»
			 
			Las prioridades asignadas a las reglas corresponden con las esperadas.
			 
			*************************************************************************
			«ELSE»
			Se han encontrado reglas cuya prioridades asignadas no son las esperadas:
			 
				«FOR entry : map.entrySet»
					La regla «entry.key» («entry.value») con prioridad («mapRealPriorities.get(entry.value)») se esperaba con priodidad («mapGeneratedPriorities.get(entry.value)»)
					 
				«ENDFOR»
			*************************************************************************	
			«ENDIF»
			'''
		)
	}
	
	def addEntryToMap(Map<String, String> map, String key, String value){
		map.put(key,value)
	}

	
	
	
	
	def makeMap(List<String> simpleEventList, List<RuleParts> complexEventList){
		simpleEventList.forEach[event | mapEvents.put(event, newArrayList.toList)]
		complexEventList.forEach[complexEvent | 
			mapEvents.put(complexEvent.insert.name, extractDependencies1(complexEvent))
		]		
	}
	
	
	def List<String> extractDependencies1(RuleParts rule){
		if (rule.fromRule.pattern !== null) {
			
			var kindOfEventList = new ArrayList<KindOfEvent>()
			var followByList = rule.fromRule.pattern.joinFollowBy.followsByJoinList
			var result = new ArrayList<String>()
			
			for (AbstractFollowBy abstractFollowBy : followByList){
				val auxList = extractDependencies2(abstractFollowBy.followBy, newArrayList, kindOfEventList)
				result.addAll(auxList)
			}
			
			/* 
			val result = extractDependencies2(rule.fromRule.pattern.followBy , newArrayList, kindOfEventList)
							.stream
							.distinct
							.collect(Collectors.toList())
			*/
			
			val distinctKindOfEventList = kindOfEventList
											.stream
											.distinct
											.collect(Collectors.toList())
					
			addDependenciesToUniqueIDMap(rule, distinctKindOfEventList)		
					
			result.stream.distinct.collect(Collectors.toList())	
		} else {
			newArrayList(rule.fromRule.event.name)
		}
	}
	
	def List<String> extractDependencies2(FollowBy followByExpression, 
											List<String> dependencies,
											List<KindOfEvent> kindOfEventList
	){
		val leftSide = followByExpression.leftSide
		val rightSideList = followByExpression.rightSide
		
		extractDependenciesOfLeftSice(leftSide, dependencies, kindOfEventList)
		extractDependenciesOfRightSice(rightSideList, dependencies, kindOfEventList)
		
		dependencies
	}
	
	def extractDependenciesOfRightSice(List<TerminalExpression> rightSideList,
										List<String> dependencies,
										List<KindOfEvent> kindOfEventList
	) {
		for(TerminalExpression terminalExpression : rightSideList){
			if(terminalExpression.every){
				extractDependencies2(terminalExpression.everyExpression, dependencies, kindOfEventList)
			} else if(terminalExpression.parenthesis){
				extractDependencies2(terminalExpression.betweenParenthesis, dependencies, kindOfEventList)
			} else{
				dependencies.add(terminalExpression.singleDefinition.simpleEvents.name)
				kindOfEventList.add(terminalExpression.singleDefinition.simpleEvents)
			}
		}
	}
	
	def extractDependenciesOfLeftSice(TerminalExpression terminalExpression, 
										List<String> dependencies,
										List<KindOfEvent> kindOfEventList
	){
		if(terminalExpression.every){
			extractDependencies2(terminalExpression.everyExpression, dependencies, kindOfEventList)
		} else if(terminalExpression.parenthesis){
			extractDependencies2(terminalExpression.betweenParenthesis, dependencies, kindOfEventList)
		} else{
			dependencies.add(terminalExpression.singleDefinition.simpleEvents.name)
			kindOfEventList.add(terminalExpression.singleDefinition.simpleEvents)
		}
	}
	
	//-------------------------------------------------------------------------------------
	
	def makeIntToRuleNameMap(List<String> simpleEventList, List<RuleParts> complexEventList, Stack<String> stack) {
		var i = 0;
		for (String simpleEventName : simpleEventList){
			var uniqueID = simpleEventName + "_" + i.toString
			mapSimpleEventToString.put(simpleEventName, simpleEventName + "_" + i.toString)
			mapUniqueId.put(uniqueID, newArrayList.toList)
			i++
		}
		for (RuleParts complexEvent : complexEventList){
			var uniqueID = complexEvent.insert.name + "_" + i.toString
			stack.push(uniqueID)
			mapRulePartsToString.put(complexEvent.insert, uniqueID)
			makeRealPrioritiesMap(complexEvent,uniqueID)
			i++
		}
	}
	
	 
	//def getUniqueIDForSimpleEvent(String simpleEventName){
	//	mapSimpleEventToString.get(simpleEventName)
	//}
	
	def getUniqueIDForComplexEvent(RuleParts complexEvent){
		mapRulePartsToString.get(complexEvent.insert)
	}
	
	//def getUniqueIDForInsertPart(Insert insert){
	//	mapRulePartsToString.get(insert)
	//}
	
	/*
	 * 
	 def getNameForUniqueKey(String value){
		val complexEvent= checkUniqueIDForComplexEvent(value)
		val simpleEvent = checkUniqueIDForSimpleEvent(value)
		if (complexEvent !== null){
			return complexEvent
		} else {
			return simpleEvent
		}
		
	}
	*/
	
	/*
	 *  
	def checkUniqueIDForSimpleEvent(String valueID){
		val result = mapSimpleEventToString.entrySet.stream.filter[entry | entry.value.equals(valueID)].collect(Collectors.toList())
		if (result.isEmpty){
			return null
		} else {
			result.get(0).key
		}
	}
	
	def checkUniqueIDForComplexEvent(String valueID){
		val result = mapRulePartsToString.entrySet.stream.filter[entry | entry.value.equals(valueID)].collect(Collectors.toList())
		if (result.isEmpty){
			return null
		} else {
			result.get(0).key.name
		}
	}
	*/
	def addDependenciesToUniqueIDMap(RuleParts rule, List<KindOfEvent> dependencies) {
												
		val newDependenciesList = new ArrayList<String>()
		
		for (KindOfEvent kindOfEvent : dependencies){
			if (kindOfEvent instanceof Event){
				newDependenciesList.add(mapSimpleEventToString.get(kindOfEvent.name))
			} else {
				newDependenciesList.addAll(getAllIDWithTheSameInsertInto(kindOfEvent.name))

			}
		}										
												
		mapUniqueId.put(getUniqueIDForComplexEvent(rule), newDependenciesList.stream.distinct.collect(Collectors.toList))
	}
	
	def getAllIDWithTheSameInsertInto(String insertName) {
		mapRulePartsToString.entrySet
			.stream
			.filter[entry | entry.key.name.equals(insertName)]
			.map[entry | entry.value]
			.collect(Collectors.toList())
	}
	
	//--------------------FOR-PRIORITIES--------------
	def makeRealPrioritiesMap(RuleParts complexEvent ,String uniqueID){
		mapRealPriorities.put(
			uniqueID
			,
			if (complexEvent.priority === null){
				0
			} else {
				complexEvent.priority.priorityInt
			}
		)
	} 
	 
	def makePriorityMap(GraphUtils graphUtils){
		mapRulePartsToString.entrySet.forEach[ entry | mapGeneratedPriorities.put(entry.value, graphUtils.getPriority(entry.value) - 1)]
	}
}
