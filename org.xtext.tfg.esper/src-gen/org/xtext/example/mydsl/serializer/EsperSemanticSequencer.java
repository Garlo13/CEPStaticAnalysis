/*
 * generated by Xtext 2.13.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.esper.AbstractFollowBy;
import org.xtext.example.mydsl.esper.Anything;
import org.xtext.example.mydsl.esper.Attributes;
import org.xtext.example.mydsl.esper.AttributesDefinition;
import org.xtext.example.mydsl.esper.DefaultMethods;
import org.xtext.example.mydsl.esper.Domainmodel;
import org.xtext.example.mydsl.esper.EsperPackage;
import org.xtext.example.mydsl.esper.Event;
import org.xtext.example.mydsl.esper.FollowBy;
import org.xtext.example.mydsl.esper.FollowByWhere;
import org.xtext.example.mydsl.esper.From;
import org.xtext.example.mydsl.esper.GroupBy;
import org.xtext.example.mydsl.esper.Having;
import org.xtext.example.mydsl.esper.Insert;
import org.xtext.example.mydsl.esper.JoinFollowBy;
import org.xtext.example.mydsl.esper.KindSelectAttributesDefinition;
import org.xtext.example.mydsl.esper.Name;
import org.xtext.example.mydsl.esper.Pattern;
import org.xtext.example.mydsl.esper.Priority;
import org.xtext.example.mydsl.esper.RuleParts;
import org.xtext.example.mydsl.esper.Select;
import org.xtext.example.mydsl.esper.SelectAttributesDefinition;
import org.xtext.example.mydsl.esper.SingleDefinition;
import org.xtext.example.mydsl.esper.SingleSelectDefinition;
import org.xtext.example.mydsl.esper.TerminalExpression;
import org.xtext.example.mydsl.esper.Timer;
import org.xtext.example.mydsl.esper.Win;
import org.xtext.example.mydsl.services.EsperGrammarAccess;

@SuppressWarnings("all")
public class EsperSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private EsperGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == EsperPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case EsperPackage.ABSTRACT_FOLLOW_BY:
				sequence_AbstractFollowBy(context, (AbstractFollowBy) semanticObject); 
				return; 
			case EsperPackage.ANYTHING:
				sequence_Anything(context, (Anything) semanticObject); 
				return; 
			case EsperPackage.ATTRIBUTES:
				sequence_Attributes(context, (Attributes) semanticObject); 
				return; 
			case EsperPackage.ATTRIBUTES_DEFINITION:
				sequence_AttributesDefinition(context, (AttributesDefinition) semanticObject); 
				return; 
			case EsperPackage.DEFAULT_METHODS:
				sequence_DefaultMethods(context, (DefaultMethods) semanticObject); 
				return; 
			case EsperPackage.DOMAINMODEL:
				sequence_Domainmodel(context, (Domainmodel) semanticObject); 
				return; 
			case EsperPackage.EVENT:
				sequence_Event(context, (Event) semanticObject); 
				return; 
			case EsperPackage.FOLLOW_BY:
				sequence_FollowBy(context, (FollowBy) semanticObject); 
				return; 
			case EsperPackage.FOLLOW_BY_WHERE:
				sequence_FollowByWhere(context, (FollowByWhere) semanticObject); 
				return; 
			case EsperPackage.FROM:
				sequence_From(context, (From) semanticObject); 
				return; 
			case EsperPackage.GROUP_BY:
				sequence_GroupBy(context, (GroupBy) semanticObject); 
				return; 
			case EsperPackage.HAVING:
				sequence_Having(context, (Having) semanticObject); 
				return; 
			case EsperPackage.INSERT:
				sequence_Insert(context, (Insert) semanticObject); 
				return; 
			case EsperPackage.JOIN_FOLLOW_BY:
				sequence_JoinFollowBy(context, (JoinFollowBy) semanticObject); 
				return; 
			case EsperPackage.KIND_SELECT_ATTRIBUTES_DEFINITION:
				sequence_KindSelectAttributesDefinition(context, (KindSelectAttributesDefinition) semanticObject); 
				return; 
			case EsperPackage.NAME:
				sequence_Name(context, (Name) semanticObject); 
				return; 
			case EsperPackage.PATTERN:
				sequence_Pattern(context, (Pattern) semanticObject); 
				return; 
			case EsperPackage.PRIORITY:
				sequence_Priority(context, (Priority) semanticObject); 
				return; 
			case EsperPackage.RULE_PARTS:
				sequence_RuleParts(context, (RuleParts) semanticObject); 
				return; 
			case EsperPackage.SELECT:
				sequence_Select(context, (Select) semanticObject); 
				return; 
			case EsperPackage.SELECT_ATTRIBUTES_DEFINITION:
				sequence_SelectAttributesDefinition(context, (SelectAttributesDefinition) semanticObject); 
				return; 
			case EsperPackage.SINGLE_DEFINITION:
				sequence_SingleDefinition(context, (SingleDefinition) semanticObject); 
				return; 
			case EsperPackage.SINGLE_SELECT_DEFINITION:
				sequence_SingleSelectDefinition(context, (SingleSelectDefinition) semanticObject); 
				return; 
			case EsperPackage.TERMINAL_EXPRESSION:
				sequence_TerminalExpression(context, (TerminalExpression) semanticObject); 
				return; 
			case EsperPackage.TIMER:
				sequence_Timer(context, (Timer) semanticObject); 
				return; 
			case EsperPackage.WIN:
				sequence_Win(context, (Win) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     AbstractFollowBy returns AbstractFollowBy
	 *
	 * Constraint:
	 *     ((followBy=FollowBy | followBy=FollowBy) wherePart=FollowByWhere?)
	 */
	protected void sequence_AbstractFollowBy(ISerializationContext context, AbstractFollowBy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Anything returns Anything
	 *     ExtraParenthesisRule returns Anything
	 *
	 * Constraint:
	 *     (operator+=Operators | extraParenthesis+=ExtraParenthesisRule)*
	 */
	protected void sequence_Anything(ISerializationContext context, Anything semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     AttributesDefinition returns AttributesDefinition
	 *
	 * Constraint:
	 *     (name+=ID type+=ID)
	 */
	protected void sequence_AttributesDefinition(ISerializationContext context, AttributesDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Attributes returns Attributes
	 *
	 * Constraint:
	 *     (attribute+=AttributesDefinition attribute+=AttributesDefinition*)
	 */
	protected void sequence_Attributes(ISerializationContext context, Attributes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DefaultMethods returns DefaultMethods
	 *
	 * Constraint:
	 *     (name=NameMethod anything=Anything)
	 */
	protected void sequence_DefaultMethods(ISerializationContext context, DefaultMethods semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.DEFAULT_METHODS__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.DEFAULT_METHODS__NAME));
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.DEFAULT_METHODS__ANYTHING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.DEFAULT_METHODS__ANYTHING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDefaultMethodsAccess().getNameNameMethodParserRuleCall_0_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getDefaultMethodsAccess().getAnythingAnythingParserRuleCall_2_0(), semanticObject.getAnything());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Domainmodel returns Domainmodel
	 *
	 * Constraint:
	 *     (rules+=RuleParts | events+=Event)+
	 */
	protected void sequence_Domainmodel(ISerializationContext context, Domainmodel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Event returns Event
	 *     KindOfEvent returns Event
	 *
	 * Constraint:
	 *     (name=ID eventattributes=Attributes)
	 */
	protected void sequence_Event(ISerializationContext context, Event semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.KIND_OF_EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.KIND_OF_EVENT__NAME));
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.EVENT__EVENTATTRIBUTES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.EVENT__EVENTATTRIBUTES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEventAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getEventAccess().getEventattributesAttributesParserRuleCall_3_0(), semanticObject.getEventattributes());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FollowByWhere returns FollowByWhere
	 *
	 * Constraint:
	 *     timer=Timer
	 */
	protected void sequence_FollowByWhere(ISerializationContext context, FollowByWhere semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.FOLLOW_BY_WHERE__TIMER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.FOLLOW_BY_WHERE__TIMER));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getFollowByWhereAccess().getTimerTimerParserRuleCall_1_1_0(), semanticObject.getTimer());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FollowBy returns FollowBy
	 *
	 * Constraint:
	 *     (leftSide=TerminalExpression rightSide+=TerminalExpression*)
	 */
	protected void sequence_FollowBy(ISerializationContext context, FollowBy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     From returns From
	 *
	 * Constraint:
	 *     ((event=[Event|ID] (anything=Anything | anything=Anything)) | pattern=Pattern)
	 */
	protected void sequence_From(ISerializationContext context, From semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     GroupBy returns GroupBy
	 *
	 * Constraint:
	 *     anything=Anything
	 */
	protected void sequence_GroupBy(ISerializationContext context, GroupBy semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.GROUP_BY__ANYTHING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.GROUP_BY__ANYTHING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getGroupByAccess().getAnythingAnythingParserRuleCall_2_0(), semanticObject.getAnything());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Having returns Having
	 *
	 * Constraint:
	 *     (defaultMethod=DefaultMethods operator=Operators anything=Anything)
	 */
	protected void sequence_Having(ISerializationContext context, Having semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.HAVING__DEFAULT_METHOD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.HAVING__DEFAULT_METHOD));
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.HAVING__OPERATOR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.HAVING__OPERATOR));
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.HAVING__ANYTHING) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.HAVING__ANYTHING));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getHavingAccess().getDefaultMethodDefaultMethodsParserRuleCall_1_0(), semanticObject.getDefaultMethod());
		feeder.accept(grammarAccess.getHavingAccess().getOperatorOperatorsEnumRuleCall_2_0(), semanticObject.getOperator());
		feeder.accept(grammarAccess.getHavingAccess().getAnythingAnythingParserRuleCall_3_0(), semanticObject.getAnything());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Insert returns Insert
	 *     KindOfEvent returns Insert
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_Insert(ISerializationContext context, Insert semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.KIND_OF_EVENT__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.KIND_OF_EVENT__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getInsertAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     JoinFollowBy returns JoinFollowBy
	 *
	 * Constraint:
	 *     (followsByJoinList+=AbstractFollowBy (operator+=Operators followsByJoinList+=AbstractFollowBy)*)
	 */
	protected void sequence_JoinFollowBy(ISerializationContext context, JoinFollowBy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     KindSelectAttributesDefinition returns KindSelectAttributesDefinition
	 *
	 * Constraint:
	 *     (singleSelectDefinition=SingleSelectDefinition | defaultMethod=DefaultMethods | int=INT | string=STRING)
	 */
	protected void sequence_KindSelectAttributesDefinition(ISerializationContext context, KindSelectAttributesDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Name returns Name
	 *
	 * Constraint:
	 *     name=STRING
	 */
	protected void sequence_Name(ISerializationContext context, Name semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.NAME__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.NAME__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getNameAccess().getNameSTRINGTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Pattern returns Pattern
	 *
	 * Constraint:
	 *     (joinFollowBy=JoinFollowBy win=Win?)
	 */
	protected void sequence_Pattern(ISerializationContext context, Pattern semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Priority returns Priority
	 *
	 * Constraint:
	 *     priorityInt=INT
	 */
	protected void sequence_Priority(ISerializationContext context, Priority semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.PRIORITY__PRIORITY_INT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.PRIORITY__PRIORITY_INT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPriorityAccess().getPriorityIntINTTerminalRuleCall_2_0(), semanticObject.getPriorityInt());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RuleParts returns RuleParts
	 *
	 * Constraint:
	 *     (
	 *         nameRule=Name 
	 *         insert=Insert 
	 *         priority=Priority? 
	 *         selectRule=Select 
	 *         fromRule=From 
	 *         groupBy=GroupBy? 
	 *         having=Having?
	 *     )
	 */
	protected void sequence_RuleParts(ISerializationContext context, RuleParts semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SelectAttributesDefinition returns SelectAttributesDefinition
	 *
	 * Constraint:
	 *     (rightSide+=KindSelectAttributesDefinition (operator+=Operators leftSide+=KindSelectAttributesDefinition)*)
	 */
	protected void sequence_SelectAttributesDefinition(ISerializationContext context, SelectAttributesDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Select returns Select
	 *
	 * Constraint:
	 *     (
	 *         ((selectAttributes+=SelectAttributesDefinition alias+=ValidID?)+ (selectAttributes+=SelectAttributesDefinition alias+=ValidID?)*) | 
	 *         asterisk?='*'
	 *     )
	 */
	protected void sequence_Select(ISerializationContext context, Select semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleDefinition returns SingleDefinition
	 *
	 * Constraint:
	 *     (name=ID? simpleEvents=[KindOfEvent|ID] anything=Anything?)
	 */
	protected void sequence_SingleDefinition(ISerializationContext context, SingleDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SingleSelectDefinition returns SingleSelectDefinition
	 *
	 * Constraint:
	 *     (event+=[SingleDefinition|ID] attribute+=ID?)
	 */
	protected void sequence_SingleSelectDefinition(ISerializationContext context, SingleSelectDefinition semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     TerminalExpression returns TerminalExpression
	 *
	 * Constraint:
	 *     ((every?='every' everyExpression=FollowBy) | (parenthesis?='(' betweenParenthesis=FollowBy) | singleDefinition=SingleDefinition)
	 */
	protected void sequence_TerminalExpression(ISerializationContext context, TerminalExpression semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Timer returns Timer
	 *
	 * Constraint:
	 *     defaultMethod=DefaultMethods
	 */
	protected void sequence_Timer(ISerializationContext context, Timer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.TIMER__DEFAULT_METHOD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.TIMER__DEFAULT_METHOD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getTimerAccess().getDefaultMethodDefaultMethodsParserRuleCall_2_0(), semanticObject.getDefaultMethod());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Win returns Win
	 *
	 * Constraint:
	 *     defaultMethod=DefaultMethods
	 */
	protected void sequence_Win(ISerializationContext context, Win semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, EsperPackage.Literals.WIN__DEFAULT_METHOD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, EsperPackage.Literals.WIN__DEFAULT_METHOD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWinAccess().getDefaultMethodDefaultMethodsParserRuleCall_2_0(), semanticObject.getDefaultMethod());
		feeder.finish();
	}
	
	
}
